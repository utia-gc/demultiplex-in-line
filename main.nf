nextflow.enable.dsl=2

include { cutadapt_demultiplex } from './modules/cutadapt_demultiplex.nf'
include { Parse_Read_Pairs     } from './subworkflows/parse_read_pairs.nf'
include { Parse_Samplesheet    } from './subworkflows/parse_samplesheet.nf'

workflow {
    Parse_Read_Pairs( params.readsSourceDir )
    ch_readPairs = Parse_Read_Pairs.out.readPairs
    ch_readPairs.dump(pretty: true, tag: 'ch_readPairs')

    Parse_Samplesheet( params.samplesheet )
    ch_sampleDecodes = Parse_Samplesheet.out.sampleDecodes
    ch_sampleDecodes.dump(pretty: true, tag: 'ch_sampleDecodes')

    // add decode information to parsed read pairs
    ch_sampleDecodes
        .combine(ch_readPairs)
        .map { decode, multiplexedNameData, reads1, reads2 ->
            multiplexedNameData['demultiplexDecode'] = decode.get(multiplexedNameData.multiplexedSampleName)

            return [ multiplexedNameData, reads1, reads2 ]
        }
        // split into samples that are truly multiplexed vs those that aren't, i.e. soloplexed
        // this keeps us from wasting time and decreasing read counts by demultiplexing samples that aren't actually multiplexed
        .branch { sampleData, reads1, reads2 ->
            multiplexed: sampleData.demultiplexDecode.size() > 1
            soloplexed:  sampleData.demultiplexDecode.size() == 1
        }
        .set { ch_sampleDecodesReadPairs }
    ch_sampleDecodesReadPairs.multiplexed
        .dump(pretty: true, tag: 'ch_multiplexedReadPairs')
        .set { ch_multiplexedReadPairs }
    ch_sampleDecodesReadPairs.soloplexed
        .dump(pretty: true, tag: 'ch_soloplexedReadPairs')
        .set { ch_soloplexedReadPairs }

    cutadapt_demultiplex(
        ch_multiplexedReadPairs,
        file("${projectDir}/assets/oligo_dt_in-line_primer_indexes.csv"),
        params.errors
    ) 
    cutadapt_demultiplex.out.demuxed
        .dump(pretty: true, tag: "ch_demuxReads")
        .set { ch_demuxReads }

    ch_demuxReads
        .map { sampleData, reads ->
            reads.each { read ->
                // get inline index ID for the read name
                def inlineIndexIDMatcher = (read.getName() =~ /^IL\d+/)
                def inlineIndexID = inlineIndexIDMatcher.find() ? inlineIndexIDMatcher[0] : null
                // skip to next iteration if there was no match to an index ID
                if (inlineIndexID == null | sampleData['demultiplexDecode'][inlineIndexID] == null) return

                // replace demultiplexed sample name generated by cutadapt with the desired sample name
                String demultiplexedSampleName = sampleData['demultiplexDecode'][inlineIndexID]['demultiplexedSampleName']
                String demuxReadName = read.getName().replaceFirst(/^(.*)(?=_S\d+_L\d{3})/, demultiplexedSampleName)
                // build destination read path
                String project = sampleData['demultiplexDecode'][inlineIndexID]['project']
                def readDestinationPath = file(params.readsDestinationBaseDir).resolve(project).resolve('fastq').resolve(demuxReadName)
                // copy reads to desination
                read.copyTo(readDestinationPath)
                log.info "Copied reads file: ${read} --> ${readDestinationPath}"
            }
        }

    ch_soloplexedReadPairs
        .map { sampleData, reads1, reads2 ->
            [reads1, reads2].each { read ->
                // replace demultiplexed sample name generated by cutadapt with the desired sample name
                String demultiplexedSampleName = "${sampleData['demultiplexDecode'].values().first()['demultiplexedSampleName']}"
                String demuxReadName = read.getName().replaceFirst(/^(.*)(?=_S\d+_L\d{3})/, demultiplexedSampleName)
                // build destination read path
                String project = "${sampleData['demultiplexDecode'].values().first()['project']}"
                def readDestinationPath = file(params.readsDestinationBaseDir).resolve(project).resolve('fastq').resolve(demuxReadName)
                // copy reads to desination
                read.copyTo(readDestinationPath)
                log.info "Copied reads file: ${read} --> ${readDestinationPath}"
            }
        }
}
